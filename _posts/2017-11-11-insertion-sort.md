---
layout: post
title: 每天一个算法之排序算法(一)
category : 基础算法
tags : [排序算法, 插入排序, 归并排序]
---
{% include JB/setup %}

从今天开始我将逐步实现经典算法图书 Introduction to Algorithms 即算法导论的部分算法,包括正文和习题中的一些算法,或许还可以拓展一下,比如B树一章中可以再实现下B+树.

因为近期在学习go语言,所以就用go写吧.先从排序算法开始吧.Let's go<!-- excerpt -->

## 插入排序
插入排序和打牌时整理牌序的方法一样,从左到右,从第二个元素开始遍历,把当前的元素插入前面已经排好序的元素中的适当位置
代码如下
```
/**
 插入排序, 输入数组A, 将A原地从小到大排序
 */
func InsertionSort(A []int) {
    //从第二个元素开始遍历, 遍历到 j 时, j以前的元素都排好序了 
    for j := 1; j < len(A); j++ {
        //保存当前元素值
        key := A[j]
        i := j - 1
        //下面这个循环将所有j前面大于A[j]的元素都向后挪一格屁股
        for ; i > 0 && key < A[i]; i-- {
            A[i+1] = A[i]
        }
        //现在key应该保存到它应该呆的位置,注意这里为什么是A[i+1],而不是A[i]设置为key.
        //因为在上面的循环中最后一次i被减了1但不满足条件,所以应该加回来
        A[i+1] = key
    }
}
```

在上面的程序中,内循环一共执行j次, 而外循环执行n=len(A)次,所以不难看出插入排序的时间复杂度为:

`T(n)=1+2+3+...+n=n(1+n)/2=O(n^2)`

## 归并排序
归并排序是将排序数组分成两部分,分别再次应用归并排序,然后将排好序的两部分做一个合并.合并之后就是一个排好序的数组.

这是典型的分治策略.分治策略将原问题拆分为几个规模更小的子问题,这时候子问题必须考虑两种情况,一是子问题可以继续拆分,则应用递归.二是如果子问题如果不能继续拆分,则终止递归,处理最简单的情况.
```
/**
 归并排序, 输入数组A, 排序的前后范围p,r, .即函数对A中p到r的元素原地排序.
 */
func MergeSort(A []int, p, r int) {
    //多于一个元素,应用分治
    if p < r {
        //找到中间元素,比如A[0:10], 那么中间q=4
        q := (r + p) / 2
        MergeSort(A, p, q)
        MergeSort(A, q + 1, r)
        //合并
        merge(A, p, q, r)
    }
}

func merge(A []int, p, q, r int) {
    //欲合并的两个数组的长度
    n1 := q - p + 1
    n2 := r - q
    //这里复制两个数组到L,R.
    //注意为了简化代码,这里数组长度都加了1, 把最后一个元素设为哨兵,这样做以防止两个数组的指标超出范围.
    //如果不这样做需要作更多判断.
    L := make([]int, n1 + 1)
    R := make([]int, n2 + 1)
    copy(L, A[p:q+1])
    copy(R, A[q+1:r+1])
    L[n1] = math.MaxInt64
    R[n2] = math.MaxInt64
    //i, j 分别指示L, R当前的位置
    i, j := 0, 0
    //比较当前L, R的元素,较小的压入A
    for k := p; k <= r; k++ {
        if L[i] <= R[j] {
            A[k] = L[i]
            i++
        } else {
            A[k] = R[j]
            j++
        }
    }
}
```

归并排序会做log(n)次分拆,这里n是数组的长度,而同一级别的子问题的合并操作加起来刚好是n, 所以归并排序时间复杂度为:

```T(n)=O(n*log(n))```

所以归并排序在规模比较大时性能会超过插入排序.实际上,归并排序已经是排序的渐进最优了算法了.

归并排序还可以做一些优化,那就是在子问题规模很小时可以直接应用插入排序,这样可以减少递归的调用层数.因为函数调用的开销也不可忽略.
